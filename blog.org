* TODO Python mutation testing
  I just discovered [[https://github.com/boxed/mutmut][mutmut]], a mutation testing system for Python, and
  I found it fascinating, so I thought I'd share. The basic idea is
  that mutmut will run your test suite multiple times, making subtle
  changes to your source files that your tests might not catch. If you
  tests continue to pass, that is a problem and mutmut tells you about
  this mutation. The mutations are things like changing ~-=~ to ~+=~,
  ~=~ in a loop to ~<=~, incrementing magic numbers by ~1~, etc.

  In some ways the result of mutation testing could just be the same
  as a code coverage tool -- if a like ~if True:~ is covered by a
  test, you'd assume that changing it to ~if False:~ would break some
  tests. But this isn't all mutation testing does. I honestly only
  played with mutmut briefly, and it was my first time doing any
  mutation testing, so this isn't a particularly nuanced example, but
  I found it interesting. :)

** The starting code
   I started out with a really simple string scrambling function:

   #+begin_src python
     import numpy as np


     def scramble(string, seed=None):
         if seed is not None:
             np.random.seed(seed)
         letters = list(string)
         return ''.join(np.random.choice(letters, size=len(letters), replace=False))
   #+end_src

   The second parameter, ~seed~, is there for testing purposes, but
   otherwise this method is fairly straightforward: take the letters
   of a string, randomly pick elements from that list of letters, then
   join them into a new string. The randomness makes this a little
   tricky to test, but it's still pretty easy:

   #+begin_src python
     def test_scramble(self):
         string = "a random test string"
         seed = np.random.randint(100)
         self.assertEqual(main.scramble(string, seed), main.scramble(string, seed))
         self.assertNotEqual(main.scramble(string, seed), string)
   #+end_src

   Because I want the scrambling to not be predictable, I don't want
   to always set the seed to some known seed. That means I can't make
   a simple assertion like ~self.assertEqual(main.scramble("hello"),
   "llohe")~. Instead I made a pair of assertions I feel pretty
   confidnet in: if I scramble a string twice it will be the same each
   time and the scrambled version won't be the same as the unscrambled
   version. These tests aren't great, but they give me a little
   assurance that the code works as I expect. And the exercise every
   line of the code.

** Mutating the tests
   When I run mutmut on my tests I learn something interesting:

   #+begin_src shell
     $ mutmut run

     - Mutation testing starting - 

     These are the steps:
     1. A full test suite run will be made to make sure we 
        can run the tests successfully and we know how long 
        it takes (to detect infinite loops for example)
     2. Mutants will be generated and checked

     Mutants are written to the cache in the .mutmut-cache 
     directory. Print found mutants with `mutmut results`.

     Legend for output:
     ðŸŽ‰ Killed mutants. The goal is for everything to end up in this bucket.
     â° Timeout. Test suite took 10 times as long as the baseline so were killed.
     ðŸ¤” Suspicious. Tests took a long time, but not long enough to be fatal.
     ðŸ™ Survived. This means your tests needs to be expanded.

     mutmut cache is out of date, clearing it...
     1. Running tests without mutations
     ? Running... Done

     2. Checking mutants
     ? 4/4  ðŸŽ‰ 2  â° 0  ðŸ¤” 0  ðŸ™ 2
   #+end_src

   Here are the details behind those two failures:

   #+begin_src shell
     $ mutmut show 3
     --- src/main.py
     +++ src/main.py
     @@ -6,5 +6,5 @@
          if seed is not None:
              np.random.seed(seed)
          letters = list(string)
     -    return ''.join(np.random.choice(letters, size=len(letters), replace=False))
     +    return 'XXXX'.join(np.random.choice(letters, size=len(letters), replace=False))

     --- src/main.py
     +++ src/main.py
     @@ -6,5 +6,5 @@
          if seed is not None:
              np.random.seed(seed)
          letters = list(string)
     -    return ''.join(np.random.choice(letters, size=len(letters), replace=False))
     +    return ''.join(np.random.choice(letters, size=len(letters), replace=True))
   #+end_src

   The first failure tells me that while my tests are indeed testing
   that the randomized letters are joined into a new string, I'm not
   testing that the letters are simply concatinated with no sapce
   between them. Someone could come along later and decide to separate
   the letters with any character they like and my tests wouldn't
   break. The second says that while I expect ~hello~ to be scrambled
   to something like ~leohl~, it /could/ instead be turned into
   ~lllll~. Neither of those are what I want at all. Mutmut found some
   good stuff here.

** Fixing my tests
   I can fix both of these problems by making testing that the new
   scrambled string uses all and only the same letters as the
   original:

   #+begin_src python
     def test_scramble(self):
         string = "a random test string"
         seed = np.random.randint(100)
         self.assertEqual(main.scramble(string, seed), main.scramble(string, seed))
         self.assertEqual(sorted(list(string)), sorted(list(main.scramble(string, seed))))
         self.assertNotEqual(main.scramble(string, seed), string)
   #+end_src

** Conclusion
   Mutmut definitely helped sharpen my thinking about how my function
   should behave. It also helped prevent what could be a difficult to
   spot regression.

   By changing ~False~ to ~True~ in my random choice call, mutmut
   changed my function in a radical way: instead of shuffling the
   letters it was now just making a string of the right length using a
   (likely proper) subset of the original letters. That's not
   'shuffling' the letters at all, at least as I understand that
   word. The issue mutmut found showed me that I hadn't refined my
   notion of 'shuffling' sufficiently.

   In a simple example like this, the 'failure' caused
   by substituting ~XXXX~ for an empty string isn't likely to ever
   bite me -- this function won't ever be changed, so I'll never
   introduce a regression like this. But in a larger projects, methods
   are often reused and repurposed in ways similar to this and the
   full ramifications of 'minor' changes aren't often apparent. Thanks
   to mutmut, I have a test that would catch if someone tried to make
   my method use a different separator for my new string.

   Given these two wins, I think mutmut (and mutation testing in
   general) is a very interesting tool. Of course, my experiments here
   are very limited and so I still have many questions about it. One
   initial concern I have about mutmut itself is that I frequently had
   this error: =fish: 'mutmut run' terminated by signal SIGSEGV
   (Address boundary error)=. I'm using Python 2.7.14 and mutmut
   1.3.1, running on MacOS 10.14.3 in a Fish shell version 3.0.0. If I
   were going to use mutmut more seriously I'd need to dig around and
   see if that is a geninue problem, and it might well not be, but it
   seems worth mentioning. That said, I'm looking forward to trying
   out mutmut on the next project where it makes sense and to learning
   more about mutation testing in general.
* TODO Deliberate practice biscuit edition
  This morning over breakfast I realized that I had, by happy
  accident, more-or-less deliberately practiced making biscuits. So
  now I'm reflecting on this and trying to figure out what bearing is
  has on my interest of deliberate practice and programming. I'm still
  not sure about that part, but I think the biscuit part is
  interesting enough to recount here.

  One morning I wanted to make biscuits for breakfast, so I searched
  the internet and found the [[https://www.whitelily.com/recipes/white-lily-light-and-fluffy-biscuits-3790][White Lily biscuit recipe]]. The biscuits
  came together pretty quickly and when I had breakfast on the table I
  was sorely disappointed. I had been successful in other recent
  baking endeavors, so I wasn't thrilled about biscuits besting me. But
  I didn't have a clear understanding of why my version of this three
  ingredient recipe was so underwhelming. So I hit the library. There
  I found exactly what I needed: [[https://www.goodreads.com/book/show/10740124-southern-biscuits][a book on southern biscuits]]. To do a
  bit of foreshadowing, there I found two things that would be crucial
  to my future deliberate practice: a dead simple two ingredient
  recipe for biscuits and enough information to form a clear mental
  representation of what a biscuit dough should look like.

  The recipe I found there was simple: mix flour and yogurt, kneed and
  shape the dough, then cut and bake. By substituting the butter and
  milk of the classic White Lily recipe for a single ingredient, this
  new recipe removed a technique-focused step that greatly complicated
  the process. My hunch was that I'd messed that step up in my first
  attempt, but when my first round of yogurt biscuits didn't turn out,
  I knew the butter wasn't the problem!

  The biscuits turned out good enough to keep working, but I knew the
  next time I made them they needed to be tweaked. I read more recipes
  in the book and learned two crucial things:

  - while I'd always believed that overworking biscuits was a huge
    offense, you actually have to kneed biscuits a little.
  - a good biscuit dough needs to be a good bit wetter than I'd realized.

  Armed with these two major corrections in my mental representation
  of the biscuit making process, I set out every Saturday morning to
  make yogurt biscuits. Each week I'd bake a batch, evaluate the
  process and results, and think through changes I'd like to make next
  time. Granted, a few of the key parts of true deliberate practice
  were missing here (e.g., I wasn't really pushing just beyond my
  limits, and I wasn't really focusing the way a top athlete or
  musician would in deliberate practice), but I think I had enough of
  the elements in place to consider it deliberate practice and not
  just <FOCUSED> practice.

  I probably made biscuits every weekend for a few months. Eventually
  routines shifted and biscuits didn't make as much sense. It has been
  a few months since I'd made biscuits but this morning I wanted to
  serve some for breakfast. I didn't have any yogurt, so I wouldn't
  make the yogurt biscuits: I'd do the White Lily recipe. I've made
  that recipe a few times since my yogurt making biscuit practice and
  it has gone pretty well. And I had a stint where I made a good
  number of pies, so I'm confident my butter-cutting skills now. But
  the biscuits this morning still resonated with me. After I cut in
  the butter and stirred in the buttermilk, the dough just looked all
  wrong. The pre-practice me would've just forged ahead and cut and
  baked these terrible biscuits. But now I know better. Even though I
  had put in the full amount of buttermilk, I could tell that the
  dough was much too dry. So I added more. And more. Much more, in
  fact, than I would've guessed I could. Then the dough was perfect
  (well, a touch wet, but I knew I could add enough flour in the
  kneading process to counter that) so I started kneading.

  The biscuits turned out beautifully. The work I'd done to both
  practice my technique /and/ to hone my mental representation of the
  process had paid off.
